@model realTimePolls.Models.PollsList
@{
    ViewBag.Message = @Model.UserProfilePicture;
}

<div class="text-center pt-0">
    @if (Context.User.Identity.IsAuthenticated)
    {
        <h3 class="text-break">Welcome, @Context.User.Identity.Name</h3>    
    }
    <div class="d-flex flex-column ">
        <input type="text" placeholder="Search by title" id="search-box"/>
        <select  id="genre-search" name="genre-search" class="Genre w-100" placeholder="Test">
            <option disabled="disabled" selected="selected">Choose a genre to sort by...</option>
        </select>
    </div>
    <div class="main-display container pt-0 mt-0 gap-5 d-flex flex-column ">
        <h3 class="no-polls-msg">No polls found.</h3>
        <table class="rwd-table">
            <tbody id="data-container" class="table-body"></tbody>
        </table>
        <div id="pagination-container" class="">
            @*Pagination Widget created here*@
        </div>
    </div>
</div>

<script src="~/js/signalr/dist/browser/signalr.js"></script>
<script src="~/js/chat.js"></script>
<script src="~/lib/paginationjs/pagination.js"></script>

<style>

    #pagination-container {
       
    }

    .pagination {
        display: inline-block;
    }

        .pagination a {
            color: black;
            float: left;
            padding: 8px 16px;
            text-decoration: none;
            transition: background-color .3s;
        }

            .pagination a.active {
                background-color: #4CAF50;
                color: white;
            }

            .pagination a:hover:not(.active) {
                background-color: #ddd;
            }

    .flex-column-user {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: center
    }

    .user-text {
        margin-bottom: 0;
        text-align: center
    }

    .no-polls-msg {
        display: none;
    }

</style>

@* Helper functions *@
<script>
 function template(polls) {
        let html = `<tr>
                    <th>User</th>
                    <th>Title</th>
                    <th>First Option</th>
                    <th>Second Option</th>
                    <th>First Vote Count</th>
                    <th>Second Vote Count</th>
                    <th>Genre</th>
                </tr>`
        
        polls.forEach(poll => {

            html += `
                    <tr class="table-data" onclick="window.location.href='/Poll?polltitle=${poll.poll.title}&pollid=${poll.poll.id}&userid=${poll.poll.userId}'">
                    <td data-th="User" data-id="${poll.poll.id}" class="table-cell">
                        <div class="user-flex">
                            <img src="${poll.profilePicture}" alt="user-image" class="avatar">
                            <p class="user-text">${poll.userName}</p>
                        </div>
                    </td>
                    <td data-th="Title" class="table-cell">
                        ${poll.poll.title}
                    </td>
                    <td data-th="First Option" class="table-cell">
                        ${poll.poll.firstOption}
                    </td>
                    <td data-th="Second Option" class="table-cell">
                        ${poll.poll.secondOption}
                    </td>
                    <td data-th="First Count" class="table-cell">
                        <span class="first-votes">${poll.firstVoteCount}</span>
                    </td>
                    <td data-th="Second Count" class="table-cell">
                        <span class="second-votes">${poll.secondVoteCount}</span>
                    </td>
                    <td data-th="Genre" class="table-cell">
                        <span>${poll.poll.genre.name}</span>
                    </td>
                </tr>
            `;
        });
        html += '</tbody></table>'; 
        return html;
    }

     const getData = async (page) => {

        const baseURL = "https://localhost:44378/Polls/Index"
        const url = page === undefined ? baseURL : baseURL + `?page=${page}`

        const userId = {
            Id: hubConnection.connection.connectionId
        }

        const response = await fetch(url, {
            headers: {
                'Accept': 'application/json'
            }
        })

        if (!response.ok) throw new Error("Failed to fetch polls")

        const polls = await response.json()
        return polls
    }

      const getSearchResults = async (text, page) => {
        const url = "https://localhost:44378/Polls/GetSearchResults?search=" + text + "&page=" + page

        const userId = {
            Id: hubConnection.connection.connectionId
        }

        const response = await fetch(url, {
            headers: {
                'Accept': 'application/json'
            }
        })

        if (!response.ok) throw new Error("Failed to fetch polls")

        const polls = await response.json()
        return polls
    }

 const checkPollCount = (polls) => {
    const tableBody = document.querySelector("#data-container");
    const paginationContainer = document.querySelector("#pagination-container")
    const noPollsMessage = document.querySelector(".no-polls-msg")
        if (polls.length === 0) {
            tableBody.style.display = "none"
            paginationContainer.firstElementChild.style.display = "none"
            noPollsMessage.style.display = "block"
            return true;
        } else {
        tableBody.style.display = "table-row-group"
        paginationContainer.firstElementChild.style.display = "flex"
        noPollsMessage.style.display = "none"
        return false
    }
}
    //maybe add a helper function to clear results when navigating, changing dropdown, or typing in search

</script>


@* Populates the grid when the first page loads *@
<script>
    $(document).ready(function () {
        const populateGrid = async () => {
            const { polls, pollCount } = await getData();
            $('#pagination-container').pagination({
                dataSource: polls,
                pageSize: 5,
                pageRange: 1,

                callback: function (data, pagination) {
                    const nextState = { additionalInformation: 'Updated the URL with JS' };
                    const nextTitle = 'Home';
                    const baseURL = `https://localhost:44378/`
                    const buttonNumber = pagination.pageNumber

                    nextURL = `?page=${buttonNumber}`
                    nextURL = baseURL + nextURL

                    window.history.replaceState(nextState, nextTitle, nextURL);

                    var html = template(data);
                    $('#data-container').html(html);
                }
            });
        };
        populateGrid();
    });
</script>

@* Populates the grid from search results *@
<script>
    try {
       const searchBox = document.getElementById("search-box")
       const genreDropdown = document.getElementById("genre-search")

        const populateGridFromSearch = async (search) => {
            const searchParams = new URLSearchParams(window.location.search);
            const page = searchParams.get('page')
            
            var dataContainer = $('#data-container');

            const { polls, pollCount } = await getSearchResults(search, page);
             
            if(checkPollCount(polls)) return

            $('#pagination-container').pagination({
                dataSource: polls,
                pageSize: 5,
                pageRange: 1,
                callback: function (data, pagination) {
                    const nextState = { additionalInformation: 'Updated the URL with JS' };
                    const nextTitle = 'Home';
                    const baseURL = `https://localhost:44378/`
                    let nextURL;
                   
                    if(search === "") {
                        nextURL = `?page=1`
                    } else {
                        nextURL = `?search=${search}`
                    }

                    nextURL = baseURL + nextURL

                    window.history.replaceState(nextState, nextTitle, nextURL);

                    var html = template(data);
                    dataContainer.html(html);
                }
            })
        };
        searchBox.addEventListener('input', async (e) => {
            genreDropdown.value = "Choose a genre to sort by..."
            populateGridFromSearch(e.target.value);
      }); 
    } catch (e) {
        console.error(e)
  }     
</script>

@* Connects client to signalR server *@
<script>
    //Set the default url to the first page when refreshing
    // if (window.location.href !== "https://localhost:44378/?page=1") window.location.replace("https://localhost:44378/?page=1");

    const oldData = @Html.Raw(Json.Serialize(@Model));

    const hubConnection = new signalR.HubConnectionBuilder()
        .withUrl("/pollHub")
        .configureLogging(signalR.LogLevel.Information)
        .build();

    async function start() {
        try {
            await hubConnection.start();
            console.log("SignalR Connected.");

        } catch (e) {
            console.error("Failed to connect with SignalR", e);
        }
    }

    hubConnection.onclose(async () => {
        await start();
    });

    // Start the connection.
    start();
</script>
 


@* Filters grid by genre *@
<script>
    const getGenreResults = async (genreId) => {

        const url = "https://localhost:44378/Polls/GetGenreResults/" + "?genreId=" + genreId

        const userId = {
            Id: hubConnection.connection.connectionId
        }

        const response = await fetch(url, {
            method: "POST",
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'

            },
            body: JSON.stringify(genreId)
        })

        if (!response.ok) throw new Error("Failed to fetch polls")

        return await response.json()
    }

    const genreDropdown = document.querySelector("#genre-search")
    
    genreDropdown.addEventListener('change', async (e) => {
        try {
            const searchBox = document.getElementById("search-box")
            if(searchBox.value !== "") searchBox.value = ""

            const searchParams = new URLSearchParams(window.location.search);
            const page = searchParams.get('page')
            const genreId = e.target.value
            const { polls, pollCount } = await getGenreResults(genreId);

            if(checkPollCount(polls)) return

            $('#pagination-container').pagination({
                dataSource: polls,
                pageSize: 5,
                pageRange: 1,
                callback: function (data, pagination) {

                    const baseURL = "https://localhost:44378/"
                    const currentUrl = window.location.href
            
                    var dataContainer = $('#data-container');

                    const genreName = e.target[genreId - 1].textContent
            
                    const nextState = { additionalInformation: 'Updated the URL with JS' };
                    const nextTitle = 'Home';

                    nextURL = "?genreId=" + genreId + "&page=" + pagination.pageNumber
                    nextURL = baseURL + nextURL

                    window.history.replaceState(nextState, nextTitle, nextURL);
                    
                    var html = template(data);
                    dataContainer.html(html);
                }
            })
        } catch (e) {
            console.error(e)
        };    
    })
</script>

@*Updates the DOM after client receives message from the server*@

<script>
    hubConnection.on("ReceiveMessage", async (user, message) => { //maybe add this to the sharedlayout instead
        try {
            const currentUrl = window.location.href
            const searchParams = new URLSearchParams(window.location.search);
            let page = searchParams.get('page')
            let search = searchParams.get('search')

            const { polls } = await getData();

            const firstVotes = document.querySelectorAll(".first-votes");

            const firstVoteIds =  Array.from(firstVotes).map(vote => parseInt(vote.parentElement.previousElementSibling.
                previousElementSibling.previousElementSibling.previousElementSibling.dataset.id))

            const secondVotes = document.querySelectorAll(".second-votes");

            const secondVoteIds = Array.from(secondVotes).map(vote => parseInt(vote.parentElement.previousElementSibling.
            previousElementSibling.previousElementSibling.previousElementSibling.dataset.id))

            for(let i = 0; i <= polls.length - 1; i++) {
               
                if (firstVoteIds.includes(polls[i].poll.id) && firstVotes[i].innerHTML != polls[i].firstVoteCount ||
                secondVoteIds.includes(polls[i].poll.id) && secondVotes[i].innerHTML != polls[i].secondVoteCount) {
                    firstVotes[i].innerHTML = polls[i].firstVoteCount
                    secondVotes[i].innerHTML = polls[i].secondVoteCount
                } 
            }  
        } catch (e) {
            console.error(e);
        }
    });
</script>
